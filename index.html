<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI VJ Automixer: Hyper-Kinetic Console</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* ==================== 
           COLOR & THEME CONFIG 
           ==================== */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Orbitron:wght@400;700&display=swap');
        :root {
            /* Primary Deck A (Electric Blue) */
            --primary-color: #06b6d4; /* Cyan 500 */
            /* Accent Deck B (Safety Orange/Red) */
            --accent-color: #f97316; /* Orange 600 */
            /* Status/Cue (Emerald Green) */
            --cue-color: #10b981; 
            /* Deep Background (Industrial Black) */
            --background-color: #000000; 
            --panel-bg: #0d0d12; /* Near Black Panel */
            --grid-line: #1e293b;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color); 
            color: #d1d5db; /* Light Gray Text */
            min-height: 100vh;
            /* Subtle grid background for industrial feel */
            background-image: linear-gradient(to right, var(--grid-line) 1px, transparent 1px), 
                              linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        /* ==================== 
           GENERAL EFFECTS 
           ==================== */
        .panel-console {
            background-color: var(--panel-bg);
            border: 1px solid #1f2937;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.9), inset 0 0 5px rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        
        /* --- VJ Mixer Monitor --- */
        .video-wrapper {
            position: relative; /* CRITICAL: Stacking context for children */
            width: 100%;
            aspect-ratio: 16 / 9;
            overflow: hidden;
            border-radius: 12px;
            /* Intense glow effect */
            box-shadow: 0 0 100px rgba(6, 182, 212, 0.3), 0 0 50px rgba(249, 115, 22, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.1); 
            background-color: #000;
        }
        
        /* CRITICAL FIX: Stacking and Sizing for Blending */
        .video-wrapper .video-container {
            position: absolute; /* Place decks on top of each other */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: opacity 0.3s ease; /* Ensure smooth blending */
        }
        
        /* Ensure the YouTube player iframe fills its container */
        #player-A, #player-B {
            width: 100%;
            height: 100%;
        }
        /* Target the actual iframe injected by YouTube API */
        #player-A iframe, #player-B iframe {
            width: 100%;
            height: 100%;
        }


        /* ==================== 
           CUSTOM CONTROLS (SKEUOMORPHIC)
           ==================== */

        /* --- Vertical Fader Track (Volume) --- */
        .vertical-slider-container {
            width: 30px;
            height: 120px;
            padding: 5px;
            background: #111827;
            border-radius: 15px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.8), 0 0 3px rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .vertical-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 120px; 
            height: 15px; /* Thinner track */
            border-radius: 8px;
            background: #000; 
            outline: none;
            transform: rotate(-90deg);
            transform-origin: center;
        }

        /* Vertical Fader Knob (Shared Style) */
        .vertical-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 5px;
            border: 2px solid #fff;
            cursor: grab;
            transition: all 0.1s;
        }
        /* Deck A Vertical Fader (Blue) */
        .slider-A::-webkit-slider-thumb {
            background: var(--primary-color);
            box-shadow: 0 0 12px var(--primary-color), inset 0 0 5px rgba(255, 255, 255, 0.5);
        }
        /* Deck B Vertical Fader (Orange) */
        .slider-B::-webkit-slider-thumb {
            background: var(--accent-color);
            box-shadow: 0 0 12px var(--accent-color), inset 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        /* --- Crossfader Styling (The most important component) --- */
        #crossfader-container {
            height: 50px;
            background: #000;
            border-radius: 25px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.9), 0 0 10px rgba(255, 255, 255, 0.1);
            padding: 10px;
            position: relative;
        }
        #crossfader {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, var(--primary-color) 0%, #374151 50%, var(--accent-color) 100%);
            border-radius: 4px;
            outline: none;
            z-index: 1;
        }
        #crossfader::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 35px;
            height: 50px; /* Large, realistic knob/handle */
            background: #4b5563; /* Dark gray handle body */
            border: 2px solid #fff;
            border-radius: 6px;
            cursor: grab;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7), inset 0 0 10px rgba(255, 255, 255, 0.3);
            transition: box-shadow 0.1s;
            z-index: 10;
        }
        /* Add color to the knob based on the dominant side */
        .fader-a-side::-webkit-slider-thumb {
             box-shadow: 0 0 15px var(--primary-color), inset 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .fader-b-side::-webkit-slider-thumb {
             box-shadow: 0 0 15px var(--accent-color), inset 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #crossfader::-webkit-slider-thumb:active {
            cursor: grabbing;
            /* Add an intense glow on grab */
             box-shadow: 0 0 30px var(--cue-color), inset 0 0 10px #fff;
        }

        /* --- Control Buttons --- */
        .control-button {
            border: 2px solid #374151;
            background: #1f2937;
            box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.8), 0 5px 15px rgba(0, 0, 0, 0.5);
            transition: all 0.1s ease;
            position: relative;
        }
        .control-button:active {
            transform: translateY(2px);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.9);
            filter: brightness(0.8);
        }
        .control-button.play-btn {
            background-color: #065f46;
            color: var(--cue-color);
            border-color: #10b981;
        }
        .control-button.pause-btn {
            background-color: #7f1d1d;
            color: #fca5a5;
            border-color: #dc2626;
        }
        .control-button.load-btn {
             background-color: #1e3a8a;
             color: #93c5fd;
             border-color: #60a5fa;
             font-size: 0.75rem;
        }
        .control-button.cue-btn {
            background-color: #4c0519;
            color: #fbcfe8;
            border-color: #e879f9;
        }
        
        /* --- Setlist Visuals --- */
        .track-active {
            background-color: #1d4ed8; /* Stronger blue background */
            border-left: 6px solid #facc15 !important; /* Yellow cue color */
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.5);
            font-weight: bold;
            color: #fff;
        }
        .track-list-item {
            border-left: 6px solid transparent;
            border-radius: 4px;
        }
        .track-list-item:hover {
             background-color: #111827; 
        }

        /* Indicator Animation */
        .playing-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 8px;
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        .playing-indicator.playing {
            opacity: 1;
            animation: pulse-glow 1s infinite alternate;
        }
        .indicator-A.playing { background-color: var(--primary-color); box-shadow: 0 0 8px var(--primary-color); }
        .indicator-B.playing { background-color: var(--accent-color); box-shadow: 0 0 8px var(--accent-color); }

        @keyframes pulse-glow {
            from { opacity: 0.5; }
            to { opacity: 1; filter: brightness(1.5); }
        }
    </style>
</head>
<body class="flex flex-col items-center p-4">
    <!-- Title with strong gradient and hyper-contrast -->
    <h1 class="text-6xl font-extrabold tracking-tighter font-['Orbitron'] text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-sky-600 mb-8 [text-shadow:_0_0_15px_rgba(6,182,212,0.8)]">
        VJ AUTOMIXER <span class="text-3xl font-light">// KINETIC CONSOLE</span>
    </h1>

    <!-- Video Player Section -->
    <div id="vj-section" class="w-full max-w-7xl mb-10" style="display: none;">
        <div class="video-wrapper">
            <!-- Deck A (Bottom Layer) -->
            <div id="deck-A" class="video-container" style="opacity: 1;">
                <div id="player-A"></div>
            </div>
            <!-- Deck B (Top Layer) -->
            <div id="deck-B" class="video-container" style="opacity: 0;">
                <div id="player-B"></div>
            </div>
        </div>
        
        <!-- Console Controls Panel -->
        <div class="mt-6 p-6 panel-console">
            
            <!-- Top Status Bar & Automation Toggle -->
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-5 border-b border-gray-700 pb-3">
                <p class="text-lg sm:text-2xl font-mono font-extrabold text-white mb-2 sm:mb-0">
                    <span class="text-xs text-cue-color mr-2 font-sans font-bold tracking-widest">NOW PLAYING:</span>
                    <span id="current-track-info" class="text-sm sm:text-lg text-gray-300">Waiting for setlist...</span>
                </p>
                <button id="toggle-automation" class="px-5 py-2 bg-red-800 hover:bg-red-700 text-white font-bold rounded-full shadow-lg transition duration-200 text-sm">
                    Automation OFF (Manual)
                </button>
            </div>
            
            <!-- Controls Grid: Deck A | Mixer | Deck B -->
            <div class="grid grid-cols-3 gap-8 mb-4">
                
                <!-- 1. DECK A CONTROLS (Cyan/Blue) -->
                <div id="controls-A" class="bg-cyan-900/10 p-5 rounded-xl border border-cyan-800 shadow-xl shadow-cyan-900/30 flex flex-col justify-between">
                    <div>
                        <h3 class="font-extrabold text-cyan-400 mb-3 flex items-center text-xl border-b border-cyan-900 pb-2">
                            DECK A (VIDEO 1)
                            <span id="indicator-A" class="playing-indicator indicator-A"></span>
                        </h3>
                        <p class="text-xs text-gray-400 font-mono mb-2">MIX LEVEL: <span id="mix-level-A" class="font-bold text-cyan-300">0%</span></p>
                        <p class="text-xs text-gray-400 font-mono">TIME: <span id="time-A" class="font-bold text-xl text-cyan-300 font-['Orbitron']">0:00</span></p>
                    </div>

                    <!-- Volume Fader & Mute Button -->
                    <div class="flex items-center mt-6">
                        <button id="mute-A" class="control-button px-3 py-2 rounded-lg text-sm text-gray-400 mr-4 cue-btn">
                             <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l6-6v16l-6-6zM17 12a4 4 0 01-8 0"></path></svg>
                        </button>
                        <div class="vertical-slider-container">
                            <input type="range" min="0" max="100" value="100" id="volume-A-slider" class="vertical-slider slider-A">
                        </div>
                        <span class="text-lg text-gray-400 ml-4 font-mono font-bold">VOL</span>
                    </div>

                    <!-- Playback Controls -->
                    <div class="mt-6 flex space-x-2">
                        <button id="play-A" class="control-button play-btn px-4 py-3 rounded-xl text-white font-bold flex-1 flex items-center justify-center text-lg">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.26-1.26L12 13.59l2.28-2.28 1.26 1.26L12 16.11l-3.54-3.53zM15.5 4l-.71-.71c-.39-.39-.99-.39-1.38 0l-.71.71H9.3c-.39 0-.77.15-1.06.44l-.71.71L7.5 5.5h9l-.79-.79z"></path></svg>
                        </button>
                        <button id="pause-A" class="control-button pause-btn px-4 py-3 rounded-xl text-white font-bold flex-1 flex items-center justify-center text-lg">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                        </button>
                    </div>
                </div>
                
                <!-- 2. CENTRAL MIXER CONTROLS -->
                <div class="bg-gray-950/50 p-5 rounded-xl border border-gray-700 shadow-2xl shadow-gray-900/80 flex flex-col justify-between items-center">
                    <h3 class="font-extrabold text-white mb-4 text-2xl font-['Orbitron']">
                        MAIN MIXER
                    </h3>
                    
                    <!-- VU Meter Style Display -->
                    <div id="fader-display-wrapper" class="w-full h-8 rounded-full overflow-hidden mb-6 bg-gray-900 border-2 border-gray-700 shadow-inner">
                        <div id="fader-display" class="h-full rounded-full transition-all duration-100 ease-linear flex justify-between items-center px-2">
                             <span id="fader-label-A" class="text-xs font-bold text-gray-300">A</span>
                             <span id="fader-label-B" class="text-xs font-bold text-gray-300">B</span>
                        </div>
                    </div>
                    
                    <!-- Crossfader (Interactive) -->
                    <div id="crossfader-container" class="w-full">
                        <input type="range" min="0" max="100" value="0" id="crossfader" class="w-full fader-a-side">
                    </div>
                    <div class="flex justify-between w-full text-sm text-gray-400 mt-2 font-mono">
                        <span class="text-cyan-400 font-bold">100% A</span>
                        <span class="text-red-400 font-bold">100% B</span>
                    </div>

                    <!-- Global Status -->
                    <div class="w-full mt-6 pt-3 border-t border-gray-800 text-center">
                        <p class="text-md text-gray-400 font-mono">
                            SESSION TIME: <span id="current-time-display" class="font-bold text-xl" style="color:var(--cue-color)">0:00</span> / <span id="duration-display" class="font-bold text-xl">0:00</span>
                        </p>
                         <p class="text-sm text-gray-500 mt-1">
                            TRACK <span id="track-index-display" class="font-bold text-lg text-white">0</span> OF 20
                        </p>
                    </div>
                </div>

                <!-- 3. DECK B CONTROLS (Orange/Red) -->
                <div id="controls-B" class="bg-orange-900/10 p-5 rounded-xl border border-orange-800 shadow-xl shadow-orange-900/30 flex flex-col justify-between">
                    <div>
                        <h3 class="font-extrabold text-orange-400 mb-3 flex items-center justify-end text-xl border-b border-orange-900 pb-2">
                            DECK B (VIDEO 2)
                            <span id="indicator-B" class="playing-indicator indicator-B"></span>
                        </h3>
                         <p class="text-xs text-gray-400 font-mono mb-2 text-right">MIX LEVEL: <span id="mix-level-B" class="font-bold text-orange-300">0%</span></p>
                        <p class="text-xs text-gray-400 font-mono text-right">TIME: <span id="time-B" class="font-bold text-xl text-orange-300 font-['Orbitron']">0:00</span></p>
                    </div>
                    
                    <!-- Volume Fader & Mute Button -->
                    <div class="flex items-center mt-6 justify-end">
                        <span class="text-lg text-gray-400 mr-4 font-mono font-bold">VOL</span>
                        <div class="vertical-slider-container">
                            <input type="range" min="0" max="100" value="0" id="volume-B-slider" class="vertical-slider slider-B">
                        </div>
                        <button id="mute-B" class="control-button px-3 py-2 rounded-lg text-sm text-gray-400 ml-4 cue-btn">
                             <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l6-6v16l-6-6zM17 12a4 4 0 01-8 0"></path></svg>
                        </button>
                    </div>

                    <!-- Playback Controls -->
                    <div class="mt-6 flex space-space-x-2">
                        <button id="play-B" class="control-button play-btn px-4 py-3 rounded-xl text-white font-bold flex-1 flex items-center justify-center text-lg">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.26-1.26L12 13.59l2.28-2.28 1.26 1.26L12 16.11l-3.54-3.53zM15.5 4l-.71-.71c-.39-.39-.99-.39-1.38 0l-.71.71H9.3c-.39 0-.77.15-1.06.44l-.71.71L7.5 5.5h9l-.79-.79z"></path></svg>
                        </button>
                        <button id="pause-B" class="control-button pause-btn px-4 py-3 rounded-xl text-white font-bold flex-1 flex items-center justify-center text-lg">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- AI Generation & Input Section -->
    <div id="input-section" class="w-full max-w-4xl mb-8 p-6 panel-console border-cyan-900/50">
        <h2 class="text-3xl font-bold text-cyan-400 mb-4 border-b border-cyan-800 pb-2">SETLIST AI GENERATOR</h2>
        <label for="location" class="block text-sm font-medium text-gray-300 mb-1">Club Location / Vibe</label>
        <input type="text" id="location" placeholder="e.g., Underground Rave, Tokyo" value="" class="input-style w-full p-3 rounded-lg mb-3 bg-gray-900 border-gray-700 text-white shadow-inner">
        
        <label for="theme" class="block text-sm font-medium text-gray-300 mb-1">Theme Night / Genre Focus</label>
        <input type="text" id="theme" placeholder="e.g., Minimal Psytrance and Abstract Glitch Art" value="" class="input-style w-full p-3 rounded-lg mb-4 bg-gray-900 border-gray-700 text-white shadow-inner">
        
        <button id="generateButton" class="w-full p-4 text-white font-bold rounded-xl text-lg flex items-center justify-center transition control-button" style="background-color: #06b6d4; border-color: #0891b2; box-shadow: 0 0 20px #06b6d4;">
            <svg class="w-6 h-6 mr-2 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
            INITIATE 20-TRACK SEQUENCE
        </button>
        <p id="default-info" class="text-center text-xs text-gray-500 mt-3">
            *Leave fields empty for a global 'Trending Visuals' mix.
        </p>
        <div id="loadingIndicator" class="hidden mt-4 text-center text-xl font-mono" style="color:var(--cue-color)">
            <svg class="animate-spin inline-block h-6 w-6 mr-3" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <span id="loadingText" class="font-mono">Generating setlist...</span>
        </div>
        <div id="errorBox" class="hidden mt-4 p-3 bg-red-900 border border-red-700 text-red-300 rounded-lg text-sm font-mono shadow-xl">
            <p class="font-semibold">SYSTEM ALERT:</p>
            <p id="errorMessage"></p>
        </div>
    </div>
    
    <!-- Setlist Display Section -->
    <div id="setlist-display" class="w-full max-w-4xl mt-6 p-6 panel-console border-orange-900/50" style="display: none;">
        <h2 class="text-3xl font-bold text-orange-400 mb-4 border-b border-orange-800 pb-2">SEQUENCE LOG (20 TRACKS)</h2>
        <p id="ai-insight" class="text-cyan-300 italic mb-4 font-mono">---</p>
        <ol id="track-list" class="space-y-1"></ol>
    </div>

    <!-- Cue Player and Status (Hidden) -->
    <div id="player-C-container" style="display: none;">
        <div id="player-C"></div>
    </div>
    <div id="cue-status-display" class="fixed bottom-4 right-4 p-4 bg-purple-900 border-2 border-purple-600 rounded-lg shadow-2xl text-white font-mono z-50 transition-transform duration-500 transform translate-x-full opacity-0" style="box-shadow: 0 0 20px #d946ef;">
        <!-- Cue Status will be inserted here -->
    </div>
    
    <!-- YouTube IFrame Player API Script -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <!-- APPLICATION SCRIPT -->
    <script>
        // ==============================================
        // CONFIGURATION & GLOBAL STATE
        // ==============================================
        const apiKey = "AIzaSyAv5NcneJ7HhAP4yH9cF2s-U5Z-PlEH8QA"; 
        const AI_MODEL = "gemini-2.5-flash-preview-09-2025";
        const TRACK_COUNT = 20;
        const FADE_DURATION_SECONDS = 8; 
        const TIMER_INTERVAL_MS = 250; 
        const FALLBACK_ID = 'dQw4w9WgXcQ'; // Rick Astley - Never Gonna Give You Up (Always available)
        
        let playerA, playerB, playerC;
        let isPlayersReady = false;
        let setlist = [];
        let setlistIndex = 0;
        let activeDeck = 'A'; 
        let nextDeck = 'B';
        let timerInterval = null; 
        let isCrossfading = false;
        let isAutomationEnabled = false; 
        
        // ==============================================
        // UI ELEMENTS (initialized inside window.onload)
        // ==============================================
        let faderDisplay, deckA, deckB, currentTrackInfo, mixLevelA, mixLevelB, currentTimeDisplay, durationDisplay, trackIndexDisplay, trackList, aiInsight;
        let generateButton, loadingIndicator, loadingText, errorBox, errorMessage, toggleAutomationBtn;
        let indicatorA, indicatorB, controlsA, controlsB;
        let volumeASlider, volumeBSlider, playA, pauseA, playB, pauseB, muteA, muteB;
        let crossfader, timeA, timeB;
        let faderLabelA, faderLabelB;
        let cueDisplay;

        function initializeUIElements() {
            // Main Display Elements
            faderDisplay = document.getElementById('fader-display');
            deckA = document.getElementById('deck-A');
            deckB = document.getElementById('deck-B');
            currentTrackInfo = document.getElementById('current-track-info');
            mixLevelA = document.getElementById('mix-level-A');
            mixLevelB = document.getElementById('mix-level-B');
            currentTimeDisplay = document.getElementById('current-time-display');
            durationDisplay = document.getElementById('duration-display');
            trackIndexDisplay = document.getElementById('track-index-display');
            trackList = document.getElementById('track-list');
            aiInsight = document.getElementById('ai-insight');
            
            // Input/Control Elements
            generateButton = document.getElementById('generateButton');
            loadingIndicator = document.getElementById('loadingIndicator');
            loadingText = document.getElementById('loadingText');
            errorBox = document.getElementById('errorBox');
            errorMessage = document.getElementById('errorMessage');
            toggleAutomationBtn = document.getElementById('toggle-automation');

            // Mixer Elements
            crossfader = document.getElementById('crossfader');
            timeA = document.getElementById('time-A');
            timeB = document.getElementById('time-B');
            faderLabelA = document.getElementById('fader-label-A');
            faderLabelB = document.getElementById('fader-label-B');

            // Deck Status and Manual Controls
            indicatorA = document.getElementById('indicator-A');
            indicatorB = document.getElementById('indicator-B');
            controlsA = document.getElementById('controls-A');
            controlsB = document.getElementById('controls-B');
            volumeASlider = document.getElementById('volume-A-slider');
            volumeBSlider = document.getElementById('volume-B-slider');
            playA = document.getElementById('play-A');
            pauseA = document.getElementById('pause-A');
            playB = document.getElementById('play-B');
            pauseB = document.getElementById('pause-B');
            muteA = document.getElementById('mute-A');
            muteB = document.getElementById('mute-B');
            cueDisplay = document.getElementById('cue-status-display');

            // Set initial state
            updateAutomationButtonUI();
            updateFader(0); // Initialize fader position
        }


        // ==============================================
        // UTILITY FUNCTIONS
        // ==============================================
        function getPlayer(deck) {
            if (deck === 'A') return playerA;
            if (deck === 'B') return playerB;
            return null;
        }
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }
        function showLoading(isLoading, phaseText = "Executing request...") {
            loadingIndicator.classList.toggle('hidden', !isLoading);
            generateButton.disabled = isLoading;
            loadingText.textContent = phaseText;
            generateButton.classList.toggle('opacity-50', isLoading);
            generateButton.style.boxShadow = isLoading ? 'none' : '0 0 20px #06b6d4';
        }
        function displayError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
        }
        function hideError() {
            errorBox.classList.add('hidden');
        }
        
        /**
         * Sanitizes and extracts the 11-character YouTube video ID from a string,
         * regardless of whether it's a raw ID, a full URL, or a short URL.
         */
        function extractYouTubeID(urlOrId) {
            if (!urlOrId) return FALLBACK_ID;
            const trimmed = urlOrId.trim();
            
            // 1. Check if it's already a clean 11-char ID
            if (trimmed.length === 11 && !trimmed.includes('/') && !trimmed.includes('=')) {
                return trimmed;
            }

            // 2. Handle standard watch URL: ...?v=ID...
            let match = trimmed.match(/[?&]v=([^&]+)/);
            if (match && match[1].length === 11) {
                return match[1];
            }

            // 3. Handle short URL: youtu.be/ID
            match = trimmed.match(/youtu\.be\/([^?&]+)/);
            if (match && match[1].length === 11) {
                return match[1];
            }

            // 4. Handle embed URL: /embed/ID
            match = trimmed.match(/\/embed\/([^?&]+)/);
             if (match && match[1].length === 11) {
                return match[1];
            }
            
            // 5. If all else fails, log warning and return the fallback
            console.warn(`[Video ID Sanitization] Failed to extract valid YouTube ID from: "${urlOrId}". Using fallback ID: ${FALLBACK_ID}`);
            return FALLBACK_ID;
        }


        function updateAutomationButtonUI() {
             if (isAutomationEnabled) {
                toggleAutomationBtn.textContent = 'Automation ON (Active)';
                toggleAutomationBtn.classList.remove('bg-red-800', 'hover:bg-red-700');
                toggleAutomationBtn.classList.add('bg-green-700', 'hover:bg-green-600');
                toggleAutomationBtn.style.boxShadow = '0 0 10px #10b981';
            } else {
                toggleAutomationBtn.textContent = 'Automation OFF (Manual)';
                toggleAutomationBtn.classList.remove('bg-green-700', 'hover:bg-green-600');
                toggleAutomationBtn.classList.add('bg-red-800', 'hover:bg-red-700');
                toggleAutomationBtn.style.boxShadow = '0 0 10px #dc2626';
            }
        }

        function toggleAutomation() {
            isAutomationEnabled = !isAutomationEnabled;
            updateAutomationButtonUI();
        }
        
        function updatePlayerIndicator(deck, isPlaying) {
            const indicator = deck === 'A' ? indicatorA : indicatorB;
            const controls = deck === 'A' ? controlsA : controlsB;
            indicator.classList.toggle('playing', isPlaying);
            
            // Highlight the control panel
            if (deck === 'A') {
                controls.classList.toggle('shadow-cyan-400/40', isPlaying);
                controls.classList.toggle('border-cyan-400', isPlaying);
                controls.classList.toggle('border-cyan-800', !isPlaying);
            } else {
                controls.classList.toggle('shadow-orange-400/40', isPlaying);
                controls.classList.toggle('border-orange-400', isPlaying);
                controls.classList.toggle('border-orange-800', !isPlaying);
            }
        }
        
        /**
         * Loads a selected track into the deck that is NOT currently active.
         */
        function loadTrackToNextDeck(trackIndex) {
            if (trackIndex >= setlist.length) return;
            
            const track = setlist[trackIndex];
            const videoId = extractYouTubeID(track.youtubeUrl);
            
            // Determine which deck is currently NOT active
            let deckToLoad = activeDeck === 'A' ? 'B' : 'A';
            nextDeck = deckToLoad; 

            // Update Setlist UI to show what's loaded
            document.querySelectorAll('.setlist-load-btn').forEach(btn => {
                btn.classList.remove('bg-emerald-700', 'border-emerald-600');
                btn.classList.add('bg-blue-700', 'border-blue-600');
                btn.textContent = 'Load to Next Deck';
            });
            const loadBtn = document.getElementById(`load-btn-${trackIndex}`);
            if (loadBtn) {
                loadBtn.classList.remove('bg-blue-700', 'border-blue-600');
                loadBtn.classList.add('bg-emerald-700', 'border-emerald-600');
                loadBtn.textContent = `QUEUED ON DECK ${deckToLoad}`;
            }

            // Update the setlist index so the next mix uses this track
            setlistIndex = trackIndex - 1; 

            // Load and pause the video on the determined deck
            loadTrack(getPlayer(deckToLoad), videoId, false, false);
            console.log(`Track ${trackIndex + 1} loaded to DECK ${deckToLoad} as the next track.`);
        }

        // ==============================================
        // MANUAL CONTROL FUNCTIONS
        // ==============================================
        function manualControl(deck, action, value = null) {
            const player = getPlayer(deck);
            if (!isPlayersReady && action !== 'crossfade') return;
            
            // Manual intervention temporarily disables automation
            if (action !== 'volume' && action !== 'mute') { 
                if (isAutomationEnabled) {
                    isAutomationEnabled = false;
                    updateAutomationButtonUI();
                }
            }
            
            switch (action) {
                case 'play':
                    player.playVideo();
                    player.unMute(); 
                    player.setVolume(parseInt(deck === 'A' ? volumeASlider.value : volumeBSlider.value)); // Use slider value
                    updatePlayerIndicator(deck, true);
                    break;
                case 'pause':
                    player.pauseVideo();
                    updatePlayerIndicator(deck, false);
                    break;
                case 'mute':
                    if (player.isMuted()) {
                        player.unMute();
                        // Reset slider value to be the new source of volume control
                        player.setVolume(parseInt(deck === 'A' ? volumeASlider.value : volumeBSlider.value));
                        document.getElementById(`mute-${deck}`).classList.remove('bg-red-700');
                    } else {
                        player.mute();
                        document.getElementById(`mute-${deck}`).classList.add('bg-red-700');
                    }
                    break;
                case 'volume':
                    const volume = parseInt(value, 10);
                    // Only apply if the deck isn't fully controlled by the crossfader right now
                    if (!player.isMuted()) { 
                        player.setVolume(volume);
                    }
                    // Update UI for the manual slider value
                    break;
                case 'crossfade':
                    // In manual mode, the crossfader value directly sets the mix
                    updateFader(parseInt(value, 10));
                    break;
            }
        }
        
        // ==============================================
        // CUEING FUNCTIONS (Player C)
        // ==============================================
        let isCueing = false;
        let cueTimeout = null;

        function stopCueing() {
            if (playerC && isCueing) {
                playerC.stopVideo();
                playerC.setVolume(0);
            }
            isCueing = false;
            if (cueTimeout) clearTimeout(cueTimeout);
            cueDisplay.classList.add('translate-x-full', 'opacity-0');
            cueDisplay.classList.remove('translate-x-0', 'opacity-100');
            cueDisplay.style.boxShadow = '0 0 0px var(--cue-color)';
        }

        function cueTrack(videoUrl) {
            if (!playerC || !isPlayersReady) return;
            
            const videoId = extractYouTubeID(videoUrl);

            if (isCueing) {
                stopCueing();
            }
            
            const track = setlist.find(t => t.youtubeUrl === videoUrl);
            const displayTitle = track ? `${track.track} - ${track.artist}` : videoUrl;

            cueDisplay.innerHTML = `<span class="text-xs text-gray-300">CUEING:</span> <span class="text-purple-300 font-bold text-lg">${displayTitle}</span> <button onclick="window.stopCueing()" class="ml-3 px-2 py-1 bg-red-700 hover:bg-red-600 rounded text-xs font-bold transition">STOP CUE</button>`;
            cueDisplay.classList.remove('translate-x-full', 'opacity-0');
            cueDisplay.classList.add('translate-x-0', 'opacity-100');
            cueDisplay.style.boxShadow = '0 0 20px #d946ef'; 
            
            playerC.loadVideoById({videoId: videoId, startSeconds: 0});
            playerC.playVideo(); 
            playerC.unMute(); 
            playerC.setVolume(80); 
            isCueing = true;
            
            // Automatically stop cueing after 15 seconds
            cueTimeout = setTimeout(stopCueing, 15000); 
        }

        // ==============================================
        // UI RENDER FUNCTIONS
        // ==============================================

        function renderSetlistUI() {
            trackList.innerHTML = setlist.map((track, index) =>
                `<li id="track-${index}" class="track-list-item p-3 text-sm transition-colors duration-300 flex flex-wrap justify-between items-center bg-gray-900/50 hover:bg-gray-800/50">
                    <div class="flex-1 min-w-0 pr-3">
                        <span class="font-['Orbitron'] w-8 text-orange-400 inline-block">${index + 1}.</span>
                        <span class="text-white font-bold">${track.track}</span>
                        <span class="text-gray-400">by ${track.artist}</span>
                    </div>
                    <div class="flex space-x-2 items-center text-xs mt-2 sm:mt-0">
                        <button id="cue-btn-${index}" onclick="cueTrack('${track.youtubeUrl}')" class="control-button cue-btn px-3 py-1 rounded-md text-white shadow-md transition">
                            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9L16 12l-6 4.5z"></path></svg>
                        </button>
                        <button id="load-btn-${index}" onclick="loadTrackToNextDeck(${index})" class="control-button load-btn setlist-load-btn px-3 py-1 bg-blue-700 border-blue-600 hover:bg-blue-600 rounded-md text-white shadow-md transition">
                            Load to Next Deck
                        </button>
                    </div>
                </li>`
            ).join('');
        }

        function highlightCurrentTrack(index) {
            document.querySelectorAll('#track-list li').forEach(li => {
                li.classList.remove('track-active');
            });
            const currentLi = document.getElementById(`track-${index}`);
            if (currentLi) {
                currentLi.classList.add('track-active');
            }
        }
        
        // ==============================================
        // AI SETLIST GENERATION (GEMINI API)
        // ==============================================
        async function fetchWithRetry(apiUrl, payload, maxRetries = 5) {
            let retryDelay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.status === 429) {
                        if (i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            retryDelay *= 2; 
                            continue;
                        } else {
                            throw new Error(`Max retries reached. Rate Limit exceeded.`);
                        }
                    }
                    if (!response.ok) {
                        const status = response.status;
                        const errorBody = await response.text();
                        throw new Error(`API Failed with status: ${status}. Response body: ${errorBody.slice(0, 100)}...`);
                    }
                    return await response.json();
                } catch (e) {
                    if (i === maxRetries - 1) throw e;
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay *= 2;
                }
            }
        }
        async function generateSetlist() {
            hideError();
            setlist = []; 
            
            const location = document.getElementById('location').value.trim();
            const theme = document.getElementById('theme').value.trim();
            
            let userQuery;
            if (location === "" && theme === "") {
                userQuery = "Generate a continuous 20-track setlist featuring globally trending songs with excellent official music videos or visuals, suitable for VJ playback. The tracks should have a high-energy dance vibe.";
            } else {
                userQuery = `Location: ${location}. Theme/Genre: ${theme}. Generate a continuous 20-track visual setlist, where the next track is mixable with the previous one. Focus on dynamic, high-contrast visuals appropriate for the theme.`;
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL}:generateContent?key=${apiKey}`; 
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { 
                    parts: [{ 
                        text: `You are 'Colin the AI DJ.' Generate an exactly ${TRACK_COUNT}-track dance music setlist. For each track, you MUST provide the FULL YouTube Video URL (e.g., https://www.youtube.com/watch?v=dQw4w9WgXcQ) in the 'youtubeUrl' field. The URL must link directly to the high-quality official or extended mix of the song, suitable for VJ/DJ playback. The response MUST be a JSON object.`
                    }] 
                },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "insight": { "type": "STRING", "description": "A brief, one-sentence justification for the setlist design, focusing on the visual flow and energy." },
                            "setlist": {
                                "type": "ARRAY",
                                "description": `The ${TRACK_COUNT} recommended tracks for a mix.`,
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "track": { "type": "STRING" },
                                        "artist": { "type": "STRING" },
                                        "youtubeUrl": { "type": "STRING", "description": "The full YouTube Video URL." }
                                    },
                                    "propertyOrdering": ["track", "artist", "youtubeUrl"]
                                }
                            }
                        },
                        "propertyOrdering": ["insight", "setlist"]
                    }
                }
            };
            try {
                showLoading(true, "ACCESSING DATA STREAMS: Generating 20-Track Setlist and finding YouTube URLs...");
                
                const result = await fetchWithRetry(apiUrl, payload);
                let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
                
                // Remove Markdown code block syntax if present
                const parsedData = JSON.parse(jsonText.replace(/\`\`\`json|\`\`\`/g, '').trim());
                
                if (!Array.isArray(parsedData.setlist) || parsedData.setlist.length !== TRACK_COUNT) {
                    throw new Error(`AI generated an invalid setlist (Expected ${TRACK_COUNT} tracks).`);
                }
                
                // Sanitize every URL received from the AI, storing the full URL for the UI
                setlist = parsedData.setlist.map(t => ({
                    ...t,
                    // Note: We are now checking for 'youtubeUrl' and storing the full URL.
                    // The video ID will be extracted during playback/loading.
                    youtubeUrl: t.youtubeUrl || `https://www.youtube.com/watch?v=${FALLBACK_ID}`
                }));
                
                // Update UI
                document.getElementById('vj-section').style.display = 'block';
                document.getElementById('setlist-display').style.display = 'block';
                aiInsight.textContent = `// AI INSIGHT: ${parsedData.insight}`;
                renderSetlistUI();
                
                // Start the mix
                startMix();
            } catch (e) {
                console.error("AI Generation Error:", e);
                displayError(`AI GENERATION FAILED. Check console for details. ${e.message}`);
                document.getElementById('vj-section').style.display = 'none';
                document.getElementById('setlist-display').style.display = 'none';
            } finally {
                showLoading(false);
            }
        }
        
        // ==============================================
        // VJ MIXER & AUTOMATION LOGIC
        // ==============================================
        
        /**
         * 1. Initialize YouTube Players (A, B, and C)
         */
        window.onYouTubeIframeAPIReady = function() {
            const playerVars = { 'controls': 0, 'modestbranding': 1, 'rel': 0, 'showinfo': 0, 'loop': 0, 'fs': 0, 'autoplay': 0 };
            
            playerA = new YT.Player('player-A', {
                videoId: FALLBACK_ID,
                events: { 'onReady': onPlayerReady, 'onError': onPlayerError, 'onStateChange': onPlayerStateChange },
                playerVars: playerVars
            });
            playerB = new YT.Player('player-B', {
                videoId: FALLBACK_ID,
                events: { 'onReady': onPlayerReady, 'onError': onPlayerError, 'onStateChange': onPlayerStateChange },
                playerVars: playerVars
            });
            playerC = new YT.Player('player-C', {
                videoId: FALLBACK_ID,
                events: { 'onReady': onPlayerReady, 'onError': onPlayerError },
                playerVars: { ...playerVars, 'volume': 0 } 
            });
        }
        
        let readyCount = 0;
        function onPlayerReady(event) {
            readyCount++;
            event.target.setVolume(0); 
            event.target.mute(); 
            
            if (readyCount === 3) { 
                isPlayersReady = true;
            }
        }
        
        function onPlayerStateChange(event) {
            const deck = event.target === playerA ? 'A' : 'B';
            updatePlayerIndicator(deck, event.data === YT.PlayerState.PLAYING);

            if (event.data === YT.PlayerState.ENDED) {
                 if (isAutomationEnabled && !isCrossfading) {
                    forceNextTrack();
                 }
            }
        }
        
        function onPlayerError(event) {
            const player = event.target;
            let deck = null;

            if (player === playerA) deck = 'A';
            if (player === playerB) deck = 'B';
            if (player === playerC) { 
                console.warn(`Cue Player error (Code ${event.data}). Stopping cueing.`);
                stopCueing();
                return;
            }
            
            if (event.data === 100 || event.data === 101 || event.data === 150) {
                console.error(`Video Error on DECK ${deck} (Code ${event.data}). Skipping track...`);
                
                if (deck === activeDeck) {
                    displayError(`VIDEO ERROR: Track ${setlistIndex + 1} (${setlist[setlistIndex].track}) unavailable. Skipping...`);
                    setTimeout(forceNextTrack, 2000); 
                } else {
                    player.loadVideoById({videoId: FALLBACK_ID, startSeconds: 0});
                    console.warn(`Next deck (${deck}) had an error, loading fallback video.`);
                }
            }
        }

        function forceNextTrack() {
            if (setlistIndex >= setlist.length - 1) {
                // End of setlist
                if (timerInterval) clearInterval(timerInterval);
                currentTrackInfo.textContent = "SESSION END: Setlist Complete. Awaiting New Sequence...";
                getPlayer(activeDeck).pauseVideo();
                getPlayer(activeDeck).setVolume(0);
                trackIndexDisplay.textContent = setlist.length;
                isCrossfading = false;
                updatePlayerIndicator(activeDeck, false);
                return;
            }
            
            const nextTrack = setlist[setlistIndex + 1];
            const expectedNextId = extractYouTubeID(nextTrack.youtubeUrl);
            
            // Check if the next track is queued on the nextDeck
            if (setlistIndex + 1 < setlist.length) {
                const nextPlayerId = getPlayer(nextDeck).getVideoData().video_id;

                if (nextPlayerId !== expectedNextId) {
                     console.warn(`Next track not loaded correctly on ${nextDeck}. Re-loading track ${setlistIndex + 2}.`);
                     loadTrack(getPlayer(nextDeck), expectedNextId, false, false);
                }
            }

            // Before swap, reset "Load to Next Deck" buttons
            document.querySelectorAll('.setlist-load-btn').forEach(btn => {
                btn.classList.remove('bg-emerald-700', 'border-emerald-600');
                btn.classList.add('bg-blue-700', 'border-blue-600');
                btn.textContent = 'Load to Next Deck';
            });
            
            setlistIndex++;
            
            const oldActiveDeck = activeDeck;
            activeDeck = nextDeck;
            nextDeck = oldActiveDeck;
            
            // The mix is now instantly 100% on the new active deck
            updateFader(activeDeck === 'A' ? 0 : 100); 
            crossfader.value = activeDeck === 'A' ? 0 : 100;
            
            // The new active player must be unmuted and playing
            getPlayer(activeDeck).unMute();
            getPlayer(activeDeck).playVideo(); 
            getPlayer(activeDeck).setVolume(100);
            updatePlayerIndicator(activeDeck, true);

            // The old deck is muted and paused
            getPlayer(nextDeck).mute();
            getPlayer(nextDeck).pauseVideo();
            getPlayer(nextDeck).setVolume(0);
            updatePlayerIndicator(nextDeck, false);
            
            // Load the next-next track into the now-available 'next' deck
            if (setlistIndex + 1 < setlist.length) {
                const nextNextTrackId = extractYouTubeID(setlist[setlistIndex + 1].youtubeUrl);
                loadTrack(getPlayer(nextDeck), nextNextTrackId, false, false);
            }
            
            trackIndexDisplay.textContent = setlistIndex + 1;
            highlightCurrentTrack(setlistIndex);
            isCrossfading = false;
        }

        function startMix() {
            if (!isPlayersReady || setlist.length === 0) return displayError("SYSTEM ERROR: Players not ready or setlist is empty.");
            
            setlistIndex = 0;
            activeDeck = 'A';
            nextDeck = 'B';
            
            const track0Id = extractYouTubeID(setlist[0].youtubeUrl);
            loadTrack(playerA, track0Id, true, true); 
            
            if (setlist.length > 1) {
                const track1Id = extractYouTubeID(setlist[1].youtubeUrl);
                loadTrack(playerB, track1Id, false, false); 
            }
            
            // Reset to A=100%
            updateFader(0);
            crossfader.value = 0;
            highlightCurrentTrack(0);
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(monitorMix, TIMER_INTERVAL_MS);
            
            currentTrackInfo.textContent = `${setlistIndex + 1}. ${setlist[setlistIndex].track} - ${setlist[setlistIndex].artist}`;

            // Reset manual volume sliders (they only control non-mixed decks)
            volumeASlider.value = 100;
            volumeBSlider.value = 0;
        }

        function loadTrack(player, videoId, shouldPlay, shouldUnmute) {
            if (!player || !videoId) return;
            player.loadVideoById({videoId: videoId, startSeconds: 0});
            
            if (shouldUnmute) {
                player.unMute();
                player.setVolume(100); 
            } else {
                player.mute();
                player.setVolume(0);
            }
            
            if (shouldPlay) {
                player.playVideo();
            } else {
                player.pauseVideo();
            }
        }
        
        function monitorMix() {
            // Manual mode takes precedence over the timing logic
            if (!isAutomationEnabled) {
                updateTimeDisplays();
                return;
            }
            
            if (isCrossfading || setlist.length === 0) return;
            const activePlayer = getPlayer(activeDeck);
            
            try {
                if (activePlayer.getPlayerState() !== YT.PlayerState.PLAYING) return;
                
                const currentTime = activePlayer.getCurrentTime();
                const duration = activePlayer.getDuration();
                const remainingTime = duration - currentTime;
                
                updateTimeDisplays(activeDeck, currentTime, duration);

                if (remainingTime <= FADE_DURATION_SECONDS && remainingTime > 0.1) {
                    if (setlistIndex + 1 < setlist.length && !isCrossfading) {
                        isCrossfading = true;
                        
                        // Ensure the next player is playing and ready to fade in
                        const nextPlayer = getPlayer(nextDeck);
                        nextPlayer.playVideo(); 
                        nextPlayer.unMute(); // Unmute the next deck so volume can be controlled by the fader
                        
                        // Start automated crossfade
                        startCrossfade(FADE_DURATION_SECONDS * 1000); 
                    }
                }
            } catch (e) {
                console.warn("Player status error (monitorMix):", e.message);
            }
        }

        function updateTimeDisplays(activeDeck = 'A', currentTime = 0, duration = 0) {
            const activePlayer = getPlayer(activeDeck);
            const otherDeck = activeDeck === 'A' ? 'B' : 'A';
            const otherPlayer = getPlayer(otherDeck);

            // Update Global Time
            if (activePlayer && activePlayer.getCurrentTime) {
                currentTime = activePlayer.getCurrentTime();
                duration = activePlayer.getDuration();
                currentTimeDisplay.textContent = formatTime(currentTime);
                durationDisplay.textContent = formatTime(duration);
            }

            // Update Deck-Specific Time
            timeA.textContent = formatTime(activePlayer?.getCurrentTime?.() || 0);
            timeB.textContent = formatTime(otherPlayer?.getCurrentTime?.() || 0);
        }
        
        function startCrossfade(durationMs) {
            let startTime = performance.now();
            let endFaderValue = activeDeck === 'A' ? 100 : 0;
            let startFaderValue = activeDeck === 'A' ? 0 : 100;
            
            const animateFade = (currentTime) => {
                if (!isAutomationEnabled) {
                    isCrossfading = false;
                    return; 
                }
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(1, elapsedTime / durationMs); 
                let faderValue;

                if (activeDeck === 'A') {
                    // Fade from 0 (A 100%) to 100 (B 100%)
                    faderValue = startFaderValue + (endFaderValue - startFaderValue) * progress;
                } else {
                    // Fade from 100 (B 100%) to 0 (A 100%)
                    faderValue = startFaderValue - (startFaderValue - endFaderValue) * progress;
                }
                
                updateFader(faderValue);
                crossfader.value = faderValue; 
                
                if (progress < 1) {
                    requestAnimationFrame(animateFade);
                } else {
                    completeCrossfade();
                }
            };
            
            requestAnimationFrame(animateFade);
        }
        
        function completeCrossfade() {
            forceNextTrack(); 
            isCrossfading = false;
        }
        
        /**
         * Core function to update all visual and audio parameters based on crossfader value (0-100).
         * 0 = Deck A is 100%. 100 = Deck B is 100%.
         */
        function updateFader(faderValue) {
            const faderInt = Math.round(faderValue);
            
            // Player A mix level: 100 down to 0
            const a_mix = 100 - faderInt; 
            // Player B mix level: 0 up to 100
            const b_mix = faderInt; 
            
            // --- Visual Updates ---
            
            // Crossfader Knob Glow
            crossfader.classList.remove('fader-a-side', 'fader-b-side');
            if (faderInt < 50) {
                 crossfader.classList.add('fader-a-side');
            } else if (faderInt > 50) {
                 crossfader.classList.add('fader-b-side');
            }

            // Fader Visual Display (VU Meter style)
            if (faderDisplay) { 
                faderDisplay.style.backgroundImage = `linear-gradient(to right, 
                    var(--primary-color) ${a_mix}%, 
                    #374151 ${a_mix}%, 
                    #374151 ${b_mix}%, 
                    var(--accent-color) ${b_mix}%)`;
                
                // Opacity (Deck B is the top layer for blending)
                deckB.style.opacity = b_mix / 100;
                deckA.style.opacity = 1;
                
                faderLabelA.style.opacity = a_mix > 10 ? 1 : 0.2;
                faderLabelB.style.opacity = b_mix > 10 ? 1 : 0.2;
                faderLabelA.style.color = a_mix > 50 ? 'var(--primary-color)' : '#9ca3af';
                faderLabelB.style.color = b_mix > 50 ? 'var(--accent-color)' : '#9ca3af';
            }

            // Update UI feedback (Mix Level % in decks)
            mixLevelA.textContent = `${a_mix}%`;
            mixLevelB.textContent = `${b_mix}%`;
            
            // --- Audio Updates ---

            // Only update volume if player is not muted by the manual deck mute button.
            if (!getPlayer('A').isMuted()) getPlayer('A').setVolume(a_mix);
            if (!getPlayer('B').isMuted()) getPlayer('B').setVolume(b_mix);
        }
        
        // ==============================================
        // MAIN ENTRY POINT (Ensures DOM is ready)
        // ==============================================

        window.onload = function() {
            initializeUIElements();
            
            // --- Event Listeners ---
            
            // AI Generation & Automation
            generateButton.addEventListener('click', generateSetlist);
            toggleAutomationBtn.addEventListener('click', toggleAutomation);
            
            // Mixer Controls
            crossfader.addEventListener('input', (e) => manualControl('MIX', 'crossfade', e.target.value));

            // Manual Deck A Controls
            playA.addEventListener('click', () => manualControl('A', 'play'));
            pauseA.addEventListener('click', () => manualControl('A', 'pause'));
            muteA.addEventListener('click', () => manualControl('A', 'mute'));
            volumeASlider.addEventListener('input', (e) => manualControl('A', 'volume', e.target.value));

            // Manual Deck B Controls
            playB.addEventListener('click', () => manualControl('B', 'play'));
            pauseB.addEventListener('click', () => manualControl('B', 'pause'));
            muteB.addEventListener('click', () => manualControl('B', 'mute'));
            volumeBSlider.addEventListener('input', (e) => manualControl('B', 'volume', e.target.value));
            
            // Expose stopCueing globally for the cue button
            window.stopCueing = stopCueing;
        };
    </script>
</body>
</html>
