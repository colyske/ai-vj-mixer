<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI VJ Automixer: Kinetic Console Interface</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        :root {
            --primary-color: #3b82f6; /* Blue 500 (A) */
            --accent-color: #f97316; /* Orange 500 (B) */
            --background-color: #0c0a09; /* Stone 950 */
            --panel-bg: #161b22;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color); 
            color: #e5e7eb;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            padding: 1rem;
        }
        /* --- VJ Mixer Styles --- */
        .video-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            overflow: hidden;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 0 50px rgba(59, 130, 246, 0.2), 0 10px 40px rgba(0, 0, 0, 0.8); /* Stronger shadow */
            background-color: #000;
        }
        .video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: opacity 0.3s ease;
        }
        #player-A, #player-B {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .input-style {
            background-color: #1c1917; 
            border: 1px solid #44403c;
            color: #f9f9f9;
            transition: border-color 0.2s;
        }
        .input-style:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        .glow-button {
            transition: all 0.2s ease;
            background: linear-gradient(90deg, #1d4ed8, #0ea5e9);
            box-shadow: 0 0 15px #0ea5e9;
        }
        .glow-button:hover {
            box-shadow: 0 0 25px #0ea5e9, 0 0 10px rgba(249, 115, 22, 0.8);
            transform: scale(1.02); /* Subtle lift */
        }

        /* --- Custom Animations --- */

        /* Pulsing effect for the currently playing track */
        @keyframes track-pulse {
            0% { background-color: rgba(59, 130, 246, 0.1); }
            50% { background-color: rgba(59, 130, 246, 0.3); }
            100% { background-color: rgba(59, 130, 246, 0.1); }
        }
        .track-active {
            animation: track-pulse 2s infinite alternate;
        }
        /* Glow for the active deck indicator */
        @keyframes player-glow {
            0% { box-shadow: 0 0 5px currentColor; opacity: 1; }
            50% { box-shadow: 0 0 15px currentColor; opacity: 0.8; }
            100% { box-shadow: 0 0 5px currentColor; opacity: 1; }
        }
        .playing-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 0.5rem;
        }
        .indicator-A.playing {
            color: var(--primary-color);
            background-color: var(--primary-color);
            animation: player-glow 1.5s infinite ease-in-out;
        }
        .indicator-B.playing {
            color: var(--accent-color);
            background-color: var(--accent-color);
            animation: player-glow 1.5s infinite ease-in-out;
        }

        /* Fader Display Enhancement */
        #fader-display-wrapper {
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            border: 1px solid #333;
        }
        .fader-glow {
            transition: box-shadow 0.2s ease;
        }
        .fader-glow-A {
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
        }
        .fader-glow-B {
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.6);
        }

        /* Volume Slider Styling */
        .volume-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
        }
        .volume-slider:hover {
            opacity: 1;
        }
        /* Deck A Slider (Blue) */
        .slider-A {
            background: #3b82f6; /* Blue 500 */
        }
        .slider-A::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Slightly bigger thumb */
            height: 18px;
            border-radius: 50%;
            background: #1e40af; /* Blue 800 */
            border: 2px solid #fff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        /* Deck B Slider (Orange) */
        .slider-B {
            background: #f97316; /* Orange 500 */
        }
        .slider-B::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Slightly bigger thumb */
            height: 18px;
            border-radius: 50%;
            background: #c2410c; /* Orange 800 */
            border: 2px solid #fff;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="flex flex-col items-center p-4">
    <h1 class="text-4xl font-extrabold tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600 mb-8">
        AI VJ Automixer Console
    </h1>
    <!-- Video Player Section -->
    <div id="vj-section" class="w-full max-w-4xl mb-8" style="display: none;">
        <div class="video-wrapper">
            <!-- Deck A (Bottom Layer) -->
            <div id="deck-A" class="video-container" style="opacity: 1;">
                <div id="player-A"></div>
            </div>
            <!-- Deck B (Top Layer) -->
            <div id="deck-B" class="video-container" style="opacity: 0;">
                <div id="player-B"></div>
            </div>
        </div>
        <!-- Deck Controls & VJ Status -->
        <div class="mt-4 p-4 bg-\[#161b22\] rounded-xl shadow-lg border border-gray-700">
            <div class="flex justify-between items-start mb-4">
                <p class="text-xl font-extrabold text-gray-100">
                    <span id="current-track-info">Waiting for setlist...</span>
                </p>
                <button id="toggle-automation" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-full shadow-md transition duration-200 text-sm">
                    Automation ON (Active)
                </button>
            </div>
            
            <!-- Deck Controls -->
            <div class="grid grid-cols-2 gap-4 mb-4">
                <!-- Deck A Controls (Blue Theme) -->
                <div id="controls-A" class="bg-blue-900/20 p-3 rounded-lg border border-blue-800 shadow-xl transition-all duration-300">
                    <h3 class="font-extrabold text-blue-400 mb-2 flex items-center">
                        DECK A 
                        <span id="indicator-A" class="playing-indicator indicator-A"></span>
                    </h3>
                    <button onclick="manualControl('A', 'play')" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded-md text-white text-sm mr-2 shadow-md">Play</button>
                    <button onclick="manualControl('A', 'pause')" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded-md text-white text-sm shadow-md">Pause</button>
                    <input type="range" min="0" max="100" value="0" oninput="manualControl('A', 'volume', this.value)" class="volume-slider slider-A mt-3">
                    <p class="text-sm text-gray-300 mt-1 font-mono">Volume: <span id="vol-A" class="font-extrabold text-blue-300">0</span>%</p>
                </div>
                <!-- Deck B Controls (Orange Theme) -->
                <div id="controls-B" class="bg-orange-900/20 p-3 rounded-lg border border-orange-800 shadow-xl transition-all duration-300">
                    <h3 class="font-extrabold text-orange-400 mb-2 flex items-center">
                        DECK B
                        <span id="indicator-B" class="playing-indicator indicator-B"></span>
                    </h3>
                    <button onclick="manualControl('B', 'play')" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded-md text-white text-sm mr-2 shadow-md">Play</button>
                    <button onclick="manualControl('B', 'pause')" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded-md text-white text-sm shadow-md">Pause</button>
                    <input type="range" min="0" max="100" value="0" oninput="manualControl('B', 'volume', this.value)" class="volume-slider slider-B mt-3">
                    <p class="text-sm text-gray-300 mt-1 font-mono">Volume: <span id="vol-B" class="font-extrabold text-orange-300">0</span>%</p>
                </div>
            </div>
            <!-- Fader Display -->
            <div class="bg-gray-800 p-3 rounded-lg flex items-center justify-center space-x-4">
                <span class="text-sm font-medium text-blue-400">A Mix: <span id="mix-level-A" class="font-bold">100%</span></span>
                <div id="fader-display-wrapper" class="w-3/4 h-3 bg-gray-900 rounded-full overflow-hidden">
                    <div id="fader-display" class="h-full bg-blue-500 rounded-full transition-all duration-100 ease-linear fader-glow" style="width: 0%;"></div>
                </div>
                <span class="text-sm font-medium text-orange-400">B Mix: <span id="mix-level-B" class="font-bold">0%</span></span>
            </div>
            <p class="text-sm text-center text-gray-400 mt-3 font-mono">
                TIME: <span id="current-time-display" class="font-bold text-lg text-green-400">0:00</span> / <span id="duration-display">0:00</span> (Track <span id="track-index-display">0</span> of 20)
            </p>
        </div>
    </div>
    <!-- AI Generation & Input Section -->
    <div id="input-section" class="w-full max-w-lg mb-8 p-6 bg-\[#1c1917\] rounded-xl shadow-2xl border border-blue-900/50">
        <h2 class="text-2xl font-bold text-blue-400 mb-4">Setlist AI</h2>
        <label for="location" class="block text-sm font-medium text-gray-300 mb-1">Club Location</label>
        <input type="text" id="location" placeholder="e.g., Warehouse District, Berlin" value="" class="input-style w-full p-3 rounded-lg mb-3">
        
        <label for="theme" class="block text-sm font-medium text-gray-300 mb-1">Theme Night / Genre Focus</label>
        <input type="text" id="theme" placeholder="e.g., 90s Industrial Techno and Dark Minimal" value="" class="input-style w-full p-3 rounded-lg mb-4">
        
        <button id="generateButton" class="glow-button w-full p-4 text-white font-bold rounded-xl text-lg flex items-center justify-center">
            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
            Generate 20-Track Setlist
        </button>
        <p id="default-info" class="text-center text-xs text-gray-400 mt-2">
            *Leave both fields empty to generate a "Trending Songs" setlist.
        </p>
        <div id="loadingIndicator" class="hidden mt-4 text-center text-blue-400">
            <svg class="animate-spin inline-block h-5 w-5 mr-3" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <span id="loadingText">Generating setlist...</span>
        </div>
        <div id="errorBox" class="hidden mt-4 p-3 bg-red-900 border border-red-700 text-red-300 rounded-lg text-sm">
            <p class="font-semibold">Error:</p>
            <p id="errorMessage"></p>
        </div>
    </div>
    
    <!-- Setlist Display Section -->
    <div id="setlist-display" class="w-full max-w-4xl mt-6 p-6 bg-\[#161b22\] rounded-xl shadow-2xl border border-gray-700" style="display: none;">
        <h2 class="text-2xl font-bold text-accent-color mb-4">Generated Setlist (20 Tracks)</h2>
        <p id="ai-insight" class="text-blue-300 italic mb-4">---</p>
        <ol id="track-list" class="space-y-2"></ol>
    </div>
    <!-- YouTube IFrame Player API Script -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // ==============================================
        // CONFIGURATION & GLOBAL STATE
        // ==============================================
        const apiKey = "AIzaSyAv5NcneJ7HhAP4yH9cF2s-U5Z-PlEH8QA"; // Canvas will provide this key at runtime
        const AI_MODEL = "gemini-2.5-flash-preview-09-2025";
        const TRACK_COUNT = 20;
        const FADE_DURATION_SECONDS = 8; 
        const TIMER_INTERVAL_MS = 250; 
        const FALLBACK_ID = 'dQw4w9WgXcQ'; // Rick Astley - Never Gonna Give You Up (Good fallback visual)
        let playerA, playerB;
        let isPlayersReady = false;
        let setlist = [];
        let setlistIndex = 0;
        let activeDeck = 'A'; 
        let nextDeck = 'B';
        let timerInterval = null; 
        let isCrossfading = false;
        let isAutomationEnabled = true;
        // UI Elements
        const faderDisplay = document.getElementById('fader-display');
        const faderWrapper = document.getElementById('fader-display-wrapper');
        const deckA = document.getElementById('deck-A');
        const deckB = document.getElementById('deck-B');
        const currentTrackInfo = document.getElementById('current-track-info');
        const mixLevelA = document.getElementById('mix-level-A');
        const mixLevelB = document.getElementById('mix-level-B');
        const currentTimeDisplay = document.getElementById('current-time-display');
        const durationDisplay = document.getElementById('duration-display');
        const trackIndexDisplay = document.getElementById('track-index-display');
        const trackList = document.getElementById('track-list');
        const aiInsight = document.getElementById('ai-insight');
        const generateButton = document.getElementById('generateButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText');
        const errorBox = document.getElementById('errorBox');
        const errorMessage = document.getElementById('errorMessage');
        const toggleAutomationBtn = document.getElementById('toggle-automation');
        const indicatorA = document.getElementById('indicator-A');
        const indicatorB = document.getElementById('indicator-B');
        const controlsA = document.getElementById('controls-A');
        const controlsB = document.getElementById('controls-B');


        // ==============================================
        // UTILITY FUNCTIONS
        // ==============================================
        function getPlayer(deck) {
            return deck === 'A' ? playerA : playerB;
        }
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }
        function showLoading(isLoading, phaseText = "Executing request...") {
            loadingIndicator.classList.toggle('hidden', !isLoading);
            generateButton.disabled = isLoading;
            loadingText.textContent = phaseText;
            generateButton.classList.toggle('opacity-50', isLoading);
        }
        function displayError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
        }
        function hideError() {
            errorBox.classList.add('hidden');
        }
        function toggleAutomation() {
            isAutomationEnabled = !isAutomationEnabled;
            toggleAutomationBtn.textContent = isAutomationEnabled ? 'Automation ON (Active)' : 'Automation OFF (Manual)';
            toggleAutomationBtn.classList.toggle('bg-green-600', isAutomationEnabled);
            toggleAutomationBtn.classList.toggle('hover:bg-green-700', isAutomationEnabled);
            toggleAutomationBtn.classList.toggle('bg-red-600', !isAutomationEnabled);
            toggleAutomationBtn.classList.toggle('hover:bg-red-700', !isAutomationEnabled);
        }
        function updatePlayerIndicator(deck, isPlaying) {
            const indicator = deck === 'A' ? indicatorA : indicatorB;
            const controls = deck === 'A' ? controlsA : controlsB;
            indicator.classList.toggle('playing', isPlaying);
            // Apply a subtle shadow/border to the entire control panel if playing
            controls.classList.toggle('shadow-blue-500/50', isPlaying && deck === 'A');
            controls.classList.toggle('shadow-orange-500/50', isPlaying && deck === 'B');
        }

        // ==============================================
        // MANUAL CONTROL FUNCTIONS
        // ==============================================
        function manualControl(deck, action, value = null) {
            const player = getPlayer(deck);
            if (!player || !isPlayersReady) return;
            // Manual intervention temporarily disables automation
            if (isAutomationEnabled) {
                isAutomationEnabled = false;
                toggleAutomationBtn.textContent = 'Automation OFF (Manual)';
                toggleAutomationBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                toggleAutomationBtn.classList.add('bg-red-600', 'hover:bg-red-700');
            }
            switch (action) {
                case 'play':
                    player.playVideo();
                    updatePlayerIndicator(deck, true);
                    break;
                case 'pause':
                    player.pauseVideo();
                    updatePlayerIndicator(deck, false);
                    break;
                case 'volume':
                    const volume = parseInt(value, 10);
                    player.setVolume(volume);
                    player.unMute();
                    document.getElementById(`vol-${deck}`).textContent = volume;
                    break;
            }
        }
        // ==============================================
        // AI SETLIST GENERATION (GEMINI API)
        // ==============================================
        async function fetchWithRetry(apiUrl, payload, maxRetries = 5, controller = null) {
            let retryDelay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller ? controller.signal : undefined
                    });
                    if (response.status === 429) {
                        if (i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            retryDelay *= 2; 
                            continue;
                        } else {
                            throw new Error(`Max retries reached. Rate Limit exceeded.`);
                        }
                    }
                    if (!response.ok) {
                        const status = response.status;
                        const errorBody = await response.text();
                        throw new Error(`API Failed with status: ${status}. Response body: ${errorBody.slice(0, 100)}...`);
                    }
                    return await response.json();
                } catch (e) {
                    if (e.name === 'AbortError') throw e;
                    if (i === maxRetries - 1) throw e;
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay *= 2;
                }
            }
        }
        async function generateSetlist() {
            hideError();
            setlist = []; // Clear existing list
            
            const location = document.getElementById('location').value.trim();
            const theme = document.getElementById('theme').value.trim();
            
            let userQuery;
            if (location === "" && theme === "") {
                userQuery = "Generate a continuous 20-track setlist featuring globally trending songs with excellent official music videos or visuals, suitable for VJ playback.";
            } else {
                userQuery = `Location: ${location}. Theme/Genre: ${theme}. Generate a continuous 20-track setlist, where the next track is mixable with the previous one.`;
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL}:generateContent?key=${apiKey}`; 
            
            // Define the structured output schema
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { 
                    parts: [{ 
                        text: `You are 'Colin the AI DJ.' Generate an exactly ${TRACK_COUNT}-track dance music setlist. For each track, you MUST provide the YouTube Video ID (e.g., dQw4w9WgXcQ) that links directly to the high-quality official or extended mix of the song, suitable for VJ/DJ playback. The response MUST be a JSON object.` 
                    }] 
                },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "insight": { "type": "STRING", "description": "A brief, one-sentence justification for the setlist design." },
                            "setlist": {
                                "type": "ARRAY",
                                "description": `The ${TRACK_COUNT} recommended tracks for a mix.`,
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "track": { "type": "STRING" },
                                        "artist": { "type": "STRING" },
                                        "youtubeId": { "type": "STRING", "description": "The high-quality YouTube Video ID." }
                                    },
                                    "propertyOrdering": ["track", "artist", "youtubeId"]
                                }
                            }
                        },
                        "propertyOrdering": ["insight", "setlist"]
                    }
                }
            };
            try {
                showLoading(true, "Generating 20-Track Setlist and finding YouTube IDs...");
                
                const result = await fetchWithRetry(apiUrl, payload);
                let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
                
                const parsedData = JSON.parse(jsonText.replace(/\`\`\`json|\`\`\`/g, '').trim());
                
                if (!Array.isArray(parsedData.setlist) || parsedData.setlist.length !== TRACK_COUNT) {
                    throw new Error(`AI generated an invalid setlist (Expected ${TRACK_COUNT} tracks).`);
                }
                
                setlist = parsedData.setlist.map(t => ({
                    ...t,
                    youtubeId: t.youtubeId?.trim() || FALLBACK_ID // Fallback ID
                }));
                
                // Update UI
                document.getElementById('vj-section').style.display = 'block';
                document.getElementById('setlist-display').style.display = 'block';
                aiInsight.textContent = parsedData.insight;
                renderSetlistUI();
                
                // Start the mix
                startMix();
            } catch (e) {
                console.error("AI Generation Error:", e);
                displayError(`AI Generation failed. Check console for details. ${e.message}`);
                document.getElementById('vj-section').style.display = 'none';
                document.getElementById('setlist-display').style.display = 'none';
            } finally {
                showLoading(false);
            }
        }
        function renderSetlistUI() {
            trackList.innerHTML = setlist.map((track, index) =>
                `<li id="track-${index}" class="p-3 rounded-lg border-b border-gray-700/50 flex justify-between items-center text-sm transition-colors duration-300">
                    <span class="font-bold w-6 text-blue-400">${index + 1}.</span>
                    <span class="flex-grow">
                        ${track.track}
                        <span class="text-gray-400">- ${track.artist}</span>
                    </span>
                    <span class="text-gray-500 text-xs">ID: ${track.youtubeId}</span>
                </li>`
            ).join('');
        }
        function highlightCurrentTrack(index) {
            document.querySelectorAll('#track-list li').forEach(li => {
                li.classList.remove('track-active', 'border-blue-500', 'bg-blue-900/30');
            });
            const currentLi = document.getElementById(`track-${index}`);
            if (currentLi) {
                currentLi.classList.add('track-active', 'border-blue-500');
          //      currentLi.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        // ==============================================
        // VJ MIXER & AUTOMATION LOGIC
        // ==============================================
        /**
         * 1. Initialize YouTube Players
         */
        window.onYouTubeIframeAPIReady = function() {
            const playerVars = { 'controls': 0, 'modestbranding': 1, 'rel': 0, 'showinfo': 0, 'loop': 0, 'fs': 0, 'autoplay': 0 };
            playerA = new YT.Player('player-A', {
                videoId: FALLBACK_ID,
                events: { 'onReady': onPlayerReady, 'onError': onPlayerError, 'onStateChange': onPlayerStateChange },
                playerVars: playerVars
            });
            playerB = new YT.Player('player-B', {
                videoId: FALLBACK_ID,
                events: { 'onReady': onPlayerReady, 'onError': onPlayerError, 'onStateChange': onPlayerStateChange },
                playerVars: playerVars
            });
        }
        let readyCount = 0;
        function onPlayerReady(event) {
            readyCount++;
            event.target.setVolume(0); 
            event.target.mute(); 
            // Set initial volume display
            document.getElementById(`vol-${event.target === playerA ? 'A' : 'B'}`).textContent = '0';
            
            if (readyCount === 2) {
                isPlayersReady = true;
            }
        }
        
        function onPlayerStateChange(event) {
            const deck = event.target === playerA ? 'A' : 'B';

            // Update playing indicator
            updatePlayerIndicator(deck, event.data === YT.PlayerState.PLAYING);

            // Check if a video has ended (state 0) - this should usually be handled by the monitorMix loop, 
            // but acts as a safeguard.
            if (event.data === YT.PlayerState.ENDED) {
                 if (isAutomationEnabled && !isCrossfading) {
                    // Force the next track if it unexpectedly ends while the mixer is idle
                    forceNextTrack();
                 }
            }
        }
        /**
         * Video Error Handling: Skips the track and loads the next one.
         */
        function onPlayerError(event) {
            const deck = event.target === playerA ? 'A' : 'B';
            
            // Error codes indicating video issues (100: not found, 101/150: embedding disabled/not playable)
            if (event.data === 100 || event.data === 101 || event.data === 150) {
                console.error(`Video Error on DECK ${deck} (Code ${event.data}). Skipping track...`);
                
                // Only act if the error happened on the currently active track
                if (deck === activeDeck) {
                    displayError(`Video for Track ${setlistIndex + 1} (${setlist[setlistIndex].track}) is unavailable. Skipping...`);
                    // Use a short delay before forcing the next track to allow the UI error to display
                    setTimeout(forceNextTrack, 1000); 
                } else {
                    // If the error is on the NEXT deck, we swap its ID to the fallback ID to prevent crash
                    // This way the next deck is ready, but plays a generic visual.
                    event.target.loadVideoById({videoId: FALLBACK_ID, startSeconds: 0});
                    console.warn(`Next deck (${deck}) had an error, loading fallback video.`);
                }
            }
        }
        /**
         * Forces the application to immediately swap to the next track.
         */
        function forceNextTrack() {
            if (setlistIndex >= setlist.length - 1) {
                // End of setlist
                clearInterval(timerInterval);
                currentTrackInfo.textContent = "Setlist Complete! Thank you for watching.";
                getPlayer(activeDeck).pauseVideo();
                getPlayer(activeDeck).setVolume(0);
                updateFader(activeDeck === 'A' ? 0 : 100);
                trackIndexDisplay.textContent = setlist.length;
                isCrossfading = false;
                updatePlayerIndicator(activeDeck, false);
                return;
            }
            // Immediately increment index and swap decks
            setlistIndex++;
            
            // Swap roles (Deck A becomes B, B becomes A)
            const oldActiveDeck = activeDeck;
            activeDeck = nextDeck;
            nextDeck = oldActiveDeck;
            
            // Instant mix state update (100% on the new active deck)
            updateFader(activeDeck === 'A' ? 0 : 100); 
            
            // The new active player starts playing and is unmuted
            getPlayer(activeDeck).playVideo();
            getPlayer(activeDeck).unMute();
            updatePlayerIndicator(activeDeck, true);
            
            // The old deck is muted and paused
            getPlayer(nextDeck).mute();
            getPlayer(nextDeck).pauseVideo();
            getPlayer(nextDeck).setVolume(0);
            updatePlayerIndicator(nextDeck, false);
            
            // Load the next-next track into the now-available 'next' deck
            if (setlistIndex + 1 < setlist.length) {
                loadTrack(getPlayer(nextDeck), setlist[setlistIndex + 1].youtubeId, false, false);
            }
            // Update UI and reset automation state
            trackIndexDisplay.textContent = setlistIndex + 1;
            highlightCurrentTrack(setlistIndex);
            isCrossfading = false;
        }
        /**
         * 2. Start the Mix after setlist generation.
         */
        function startMix() {
            if (!isPlayersReady || setlist.length === 0) return displayError("Players not ready or setlist is empty.");
            
            // Initial state
            setlistIndex = 0;
            activeDeck = 'A';
            nextDeck = 'B';
            
            // Load and play the first track (Deck A)
            loadTrack(playerA, setlist[0].youtubeId, true, true); 
            updatePlayerIndicator('A', true);
            updatePlayerIndicator('B', false);
            
            // Load the second track (Deck B)
            if (setlist.length > 1) {
                loadTrack(playerB, setlist[1].youtubeId, false, false); 
            }
            
            // Set initial mix state: A=100%, B=0%
            updateFader(0);
            highlightCurrentTrack(0);
            // Start the monitoring loop
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(monitorMix, TIMER_INTERVAL_MS);
            
            // Ensure automation is on by default after generating a setlist
            if (!isAutomationEnabled) toggleAutomation();
        }
        /**
         * Loads a track onto a player.
         */
        function loadTrack(player, videoId, shouldPlay, shouldUnmute) {
            if (!player || !videoId) return;
            // Load the track
            player.loadVideoById({videoId: videoId, startSeconds: 0});
            
            // Set volume/mute state
            if (shouldUnmute) {
                player.unMute();
            } else {
                player.mute();
            }
            
            // Start video playback
            if (shouldPlay) {
                player.playVideo();
            } else {
                player.pauseVideo();
            }
        }
        /**
         * 3. Main Loop: Monitors the active track and initiates crossfades.
         */
        function monitorMix() {
            if (isCrossfading || !isAutomationEnabled || setlist.length === 0) return;
            const activePlayer = getPlayer(activeDeck);
            
            try {
                // If the active player is paused, the AI waits.
                if (activePlayer.getPlayerState() !== YT.PlayerState.PLAYING) return;
                
                const currentTime = activePlayer.getCurrentTime();
                const duration = activePlayer.getDuration();
                const remainingTime = duration - currentTime;
                // Update status display
                currentTrackInfo.textContent = `${setlistIndex + 1}. ${setlist[setlistIndex].track} - ${setlist[setlistIndex].artist}`;
                currentTimeDisplay.textContent = formatTime(currentTime);
                durationDisplay.textContent = formatTime(duration);
                trackIndexDisplay.textContent = setlistIndex + 1;
                // If the track is near its end, start the crossfade
                if (remainingTime <= FADE_DURATION_SECONDS && remainingTime > 0.1) {
                    // Check if we have a next track ready
                    if (setlistIndex + 1 < setlist.length) {
                        isCrossfading = true;
                        
                        // Start the next deck and crossfade
                        const nextPlayer = getPlayer(nextDeck);
                        // Start playing the next track just before the fade begins
                        nextPlayer.playVideo(); 
                        nextPlayer.unMute(); 
                        
                        startCrossfade(FADE_DURATION_SECONDS * 1000); 
                        // Pre-load the track after next track
                        if (setlistIndex + 2 < setlist.length) {
                            const trackToLoad = setlist[setlistIndex + 2];
                            const loadDeck = nextDeck; // The deck that will be free soon
                            loadTrack(getPlayer(loadDeck), trackToLoad.youtubeId, false, false);
                        }
                    } else if (remainingTime <= 0.1 && setlistIndex === setlist.length - 1) {
                    // End of Setlist logic
                        clearInterval(timerInterval);
                        currentTrackInfo.textContent = "Setlist Complete! Thank you for watching.";
                        activePlayer.pauseVideo();
                        activePlayer.setVolume(0);
                        updateFader(activeDeck === 'A' ? 0 : 100);
                        trackIndexDisplay.textContent = setlist.length;
                    }
                }
            } catch (e) {
                // Handle potential YT API errors during monitoring
                console.warn("Player status error, attempting to restart monitoring:", e.message);
            }
        }
        
        /**
         * 4. Smoothly transitions the mix over the duration.
         */
        function startCrossfade(durationMs) {
            let startTime = performance.now();
            let endFaderValue = activeDeck === 'A' ? 100 : 0;
            let startFaderValue = activeDeck === 'A' ? 0 : 100;
            const animateFade = (currentTime) => {
                // Automation check inside the loop is crucial for manual override
                if (!isAutomationEnabled) {
                    isCrossfading = false;
                    return; 
                }
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(1, elapsedTime / durationMs); 
                let faderValue;
                if (activeDeck === 'A') {
                    // A -> B transition (0 to 100)
                    faderValue = startFaderValue + (endFaderValue - startFaderValue) * progress;
                } else {
                    // B -> A transition (100 to 0)
                    faderValue = startFaderValue - (startFaderValue - endFaderValue) * progress;
                }
                
                updateFader(faderValue);
                if (progress < 1) {
                    requestAnimationFrame(animateFade);
                } else {
                    // Fade is complete
                    completeCrossfade();
                }
            };
            
            requestAnimationFrame(animateFade);
        }
        
        /**
         * 5. Swaps deck roles and increments the setlist index.
         */
        function completeCrossfade() {
            // Check if we actually have a next track to transition to
            if (setlistIndex >= setlist.length - 1) {
                 // Final track finished
                 forceNextTrack();
                 return;
            }
            // Update index and UI
            setlistIndex++;
            trackIndexDisplay.textContent = setlistIndex + 1;
            highlightCurrentTrack(setlistIndex);
            // Swap deck roles
            const oldActiveDeck = activeDeck;
            activeDeck = nextDeck;
            nextDeck = oldActiveDeck;
            
            // Mute and pause the deck that just finished its track
            const oldActivePlayer = getPlayer(nextDeck);
            oldActivePlayer.mute();
            oldActivePlayer.pauseVideo();
            oldActivePlayer.setVolume(0);
            updatePlayerIndicator(nextDeck, false);
            
            // The new active deck should now be visually active
            updatePlayerIndicator(activeDeck, true);
            
            // If there's another track, pre-load the next-next one
            if (setlistIndex + 1 < setlist.length) {
                const trackToLoad = setlist[setlistIndex + 1];
                loadTrack(getPlayer(nextDeck), trackToLoad.youtubeId, false, false);
            }
            isCrossfading = false;
        }
        /**
         * 6. Core Logic: Updates volume and opacity based on fader position (0-100).
         */
        function updateFader(faderValue) {
            const faderInt = Math.round(faderValue);
            // DECK A: Fades out as fader goes from 0 (100%) to 100 (0%)
            const a_mix = 100 - faderInt; 
            
            // DECK B: Fades in as fader goes from 0 (0%) to 100 (100%)
            const b_mix = faderInt; 
            const b_opacity = b_mix / 100;

            // Fader Visual Glow Logic: 
            // 0-20 (mostly A) -> Glow A
            // 80-100 (mostly B) -> Glow B
            faderDisplay.classList.remove('fader-glow-A', 'fader-glow-B');
            faderWrapper.classList.remove('fader-glow-A', 'fader-glow-B');

            if (faderInt < 20) {
                // Focus on A
                faderDisplay.classList.add('bg-blue-500');
                faderDisplay.classList.remove('bg-orange-500');
                faderWrapper.classList.add('fader-glow-A');
            } else if (faderInt > 80) {
                 // Focus on B
                faderDisplay.classList.add('bg-orange-500');
                faderDisplay.classList.remove('bg-blue-500');
                faderWrapper.classList.add('fader-glow-B');
            } else {
                // Crossfading/Neutral zone (use a blend color or just blue as the base)
                faderDisplay.classList.add('bg-blue-500');
                faderDisplay.classList.remove('bg-orange-500');
            }

            // Apply Volume Control (YouTube volume is 0-100)
            playerA.setVolume(a_mix); 
            playerB.setVolume(b_mix);
            // Update manual volume display to reflect the current automated mix
            document.getElementById('vol-A').textContent = a_mix;
            document.getElementById('vol-B').textContent = b_mix;
            
            // Apply Opacity Control (Deck B is the top layer)
            deckB.style.opacity = b_opacity;
            deckA.style.opacity = 1;
            // Update UI feedback
            mixLevelA.textContent = `${a_mix}%`;
            mixLevelB.textContent = `${b_mix}%`;
            faderDisplay.style.width = `${faderInt}%`;

            // Update player indicators during a manual override or at the endpoints of the mix
            if (!isAutomationEnabled) {
                updatePlayerIndicator('A', playerA.getPlayerState() === YT.PlayerState.PLAYING);
                updatePlayerIndicator('B', playerB.getPlayerState() === YT.PlayerState.PLAYING);
            }
        }

        // ==============================================
        // EVENT LISTENERS
        // ==============================================
        generateButton.addEventListener('click', generateSetlist);
        toggleAutomationBtn.addEventListener('click', toggleAutomation);
    </script>
</body>
</html>
